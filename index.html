<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Do one thing at a time and do well">
<meta property="og:type" content="website">
<meta property="og:title" content="学然后知不足">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="学然后知不足">
<meta property="og:description" content="Do one thing at a time and do well">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学然后知不足">
<meta name="twitter:description" content="Do one thing at a time and do well">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>学然后知不足</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">学然后知不足</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/Hello/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/Hello/" itemprop="url">Hello</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T11:42:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/2.png" alt="图片注释" title="图片标题"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/ios提审报错：No-suitable-application-records-were-found-Verify-your-bundle-identifier-xx-is-correct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/ios提审报错：No-suitable-application-records-were-found-Verify-your-bundle-identifier-xx-is-correct/" itemprop="url">ios提审报错：No suitable application records were found. Verify your bundle identifier 'xx' is correct</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T20:52:56+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/上线问题解决/" itemprop="url" rel="index">
                    <span itemprop="name">上线问题解决</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ios提审报错：No suitable application records were found. Verify your bundle identifier ‘xx’ is correct</p>
<p>1) 检查多个开发者账号是否提交时选择错了<br>2) 在iTunes Connect中是否建立了bundle id对应的App</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/升级到xcode8后，发布上传后构建版本不显示/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/升级到xcode8后，发布上传后构建版本不显示/" itemprop="url">升级到xcode8后，发布上传后构建版本不显示</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T20:52:32+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/上线问题解决/" itemprop="url" rel="index">
                    <span itemprop="name">上线问题解决</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次使用Xcode8发布新版本应用时，向往常一样使用 Application Loader打包上传，很快上传成功，在活动中可以看到一个构建版本正在处理中，以往这种情况只需要等半个小时左右，就会有可用的构建版本，但是这次等了一个多小时依旧没有任何提示，久违的小加号一直没有出现，再次查看活动时，发现之前正在处理的构建版本不见了，没有任何提示，查看注册开发者账号的邮箱。 才知道原来iOS10中，Apple更加注重了用户的权限与隐私，如果上传的应用中需要访问用户的隐私，则必须在plist中添加权限描述，其中，通讯录、相册、麦克风三个权限是必须添加的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/【iOS报错】Internal-error-Please-file-a-bug-at-bugreport-apple-com-and-attach-var-folders-v5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/【iOS报错】Internal-error-Please-file-a-bug-at-bugreport-apple-com-and-attach-var-folders-v5/" itemprop="url">【iOS报错】Internal error. Please file a bug at bugreport.apple.com and attach /var/folders/v5/......</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T20:51:44+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/上线问题解决/" itemprop="url" rel="index">
                    <span itemprop="name">上线问题解决</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/Users/sunmingyue/Desktop/1.png" alt="1"></p>

<p>/Users/sunmingyue/Desktop/Blog/source/_posts/Hello.md</p>
<p>解决方法：<br>cmd + shift + k<br>cmd + option + shift + k<br>Restart Xcode<br>/Users/sunmingyue/Desktop/Blog/source/_posts/Hello.md</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/数据库-性能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/数据库-性能/" itemprop="url">数据库 - 性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T16:09:09+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>假如要提高<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a>的性能，可以做如下思路整理： </p>
<ol>
<li>不在主线程处理数据库查询，可以创建dispatch Queue </li>
<li>数据库顺序执行，Queue串行处理block任务 </li>
<li>最好使用SQLite Transaction处理一组操作，但是注意在begin 与end之间不可嵌套；需要嵌套可以使用save point 语法；假如数据查询出错可以自动或手动回滚数据(rollback) </li>
<li>表内数据量大时，可通过列索引提高查询性能 create index </li>
<li>频繁查询数据时，可以考虑缓存策略</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/内存检测-instrument介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/内存检测-instrument介绍/" itemprop="url">内存检测 - instrument介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T16:08:48+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存检测-instrument"><a href="#内存检测-instrument" class="headerlink" title="内存检测 - instrument"></a>内存检测 - instrument</h3><h4 id="关于Instruments"><a href="#关于Instruments" class="headerlink" title="关于Instruments"></a><strong>关于Instruments</strong></h4><p>instruments 是一个强大的、灵活的 性能分析 和测试工具的Xcode工具集的一部分。它的目的是帮助您配置您的OS X和iOS应用程序、进程和设备，以便更好地理解和优化他们的行为和性能。从应用程序开发过程的开始将工具集成到您的工作流中，可以帮助您在开发周期的早期找到问题。</p>
<p>在Instruments中，您使用专门的工具，来跟踪应用程序、进程和设备的不同方面。Instruments收集数据作为它的概况，并向您详细介绍分析结果。</p>
<p>与其他性能和调试工具不同，Instruments允许您收集大量不同类型的数据，并排查看它们。这使得识别可能被忽略的趋势变得更容易。例如，应用程序可能会显示由于多个开放网络连接而导致的大量内存增长。通过使用Allocations 和Connections工具一起，您可以识别不关闭的连接，从而导致快速的内存增长原因。</p>
<p>通过有效地使用Instruments，您可以：</p>
<ul>
<li>检查一个或多个应用程序或进程的行为</li>
<li>检查设备特定的功能，如Wi-Fi和蓝牙</li>
<li>在模拟器或物理设备上执行概要分析</li>
<li>创建自定义的DTrace仪器分析方面的系统和应用程序的行为</li>
<li>追踪问题在你的源代码</li>
<li>对应用程序进行性能分析</li>
<li>查找应用程序中的内存问题，如泄漏、废弃内存和僵尸</li>
<li>找出优化你的应用程序以提高电源效率的方法</li>
<li>执行一般系统级故障排除</li>
<li>将工具配置保存为模板</li>
</ul>
<p>虽然它是嵌入在可使用Xcode，但Instruments是一个单独的应用程序，如果需要的话可以使用独立。</p>
<h3 id="The-Instruments-Workflow"><a href="#The-Instruments-Workflow" class="headerlink" title="The Instruments Workflow"></a><strong>The Instruments Workflow</strong></h3><p>Instruments看起来是一个复杂的app，的确如此，因为它能够用来收集app的各种有用的信息，帮助你诊断和解决问题。然而，从整体上看，instrument的工作流程相对比较简单。如图：</p>
<p><img src="http://images2015.cnblogs.com/blog/924077/201604/924077-20160418191843570-518724625.png" alt="img"></p>
<p>概括来说，使用Instruments一般包括以下几步：</p>
<ol>
<li>创建一个包含想要使用的工具和环境的记录文档。</li>
<li>指定一个设备和一个要监测的app。</li>
<li>监测app。</li>
<li>分析获取到的数据。</li>
<li>修复源码中的问题。</li>
</ol>
<h4 id="了解何时使用Instruments"><a href="#了解何时使用Instruments" class="headerlink" title="了解何时使用Instruments"></a>了解何时使用Instruments</h4><p>使用Xcode测试app时，先不启用Instruments，先打开debug navigator（左上角按钮第六个）。这里提供了一些抽象程度较高的信息，这些信息和app的CPU、内存、电量使用等有关系。通常，debug navigator提供的信息是让开发者快速的改善性能和解决一般性问题。当开发者需要更加详细的分析数据的时候，Instruments派上用场了。</p>
<p><img src="http://images2015.cnblogs.com/blog/924077/201604/924077-20160418191904820-1877176319.png" alt="img"></p>
<h3 id="About-This-Document-文档结构说明"><a href="#About-This-Document-文档结构说明" class="headerlink" title="About This Document 文档结构说明"></a>About This Document 文档结构说明</h3><p>为了方便开发者快速找到想要的信息，这个文档按照Instruments不同的关注点来组织。</p>
<ul>
<li>第一部分关注使用Instruments。包括创建一个document、找到一个你需要的具体的instrument工具、分析app、分析数据等等。在这里可以知道Instruments的一般典型操作。</li>
<li>第二部分涵盖了更多具体领域的任务，比如提高性能、解决内存问题、提高电池使用时间等。</li>
<li>最后一部分给出了个性化的instruments和模板的使用指南，还有一些其他的资源和参考。</li>
</ul>
<h4 id="Prerequisites-先决条件"><a href="#Prerequisites-先决条件" class="headerlink" title="Prerequisites 先决条件"></a>Prerequisites 先决条件</h4><p>Background Knowledge 你需要了解的知识</p>
<p>使用Instruments之前，你需要对Xcode的工作十分了解，还有app开发的相关概念，比如building和running一个app，如何使用真机调试等。</p>
<p>你还需要熟悉你想要监测的参数的核心概念。比如你想要查看app的内存使用情况，那么你需要知道一些内存管理的知识，和内存可能潜在的问题（内存泄露、僵尸对象）。如果你想要查看app的性能问题，你需要了解CPU和线程使用。如果你想解决电池使用过快的问题，你需要了解各种影响电池使用的事情，比如屏幕亮度，网络接口（GPS、蓝牙、Wi-Fi）使用，和timer的使用。</p>
<p>这个文档中会提及一些背景知识。外部有些资源可以查看： </p>
<ul>
<li>相关文档（请查看原文超连接）</li>
<li>WWDC Videos</li>
</ul>
<h4 id="System-Requirements-系统要求"><a href="#System-Requirements-系统要求" class="headerlink" title="System Requirements 系统要求"></a>System Requirements 系统要求</h4><p>Instruments安装在Xcode里。如果你还没有安装Xcode，先下载安装。</p>
<p>如果你打算在真机上分析app，需要provision你的设备。参考Lauching Your App on Decvices（请查看原文连接）。</p>
<p>注意：</p>
<p>Instruments在Xcode3.0以后、OS X v10.5以后可用。</p>
<p>Instruments可以分析iOS6以后的设备。</p>
<h1 id="2-About-Memory-Analysis"><a href="#2-About-Memory-Analysis" class="headerlink" title="2. About Memory Analysis"></a>2. About Memory Analysis</h1><p>无论什么时候APP创建对象，系统都会为对象分配内存。惯例上，APP将跟踪这些对象，并且在不需要的时候释放它们以至于能够为其它对象重新分配内存。ARC将使得内存事情变得非常简单，将由系统负责内存管理。随着ARC的出现，系统将监控对象，使对象在合适的时候分配和释放，APP将几乎不需要做什么工作。不管内存如何管理，但是，即使是最好的APP在某些情况下也可能遇到难以定位的内存问题。</p>
<p>Instruments能够帮助绘制APP是怎样使用内存的图片，Instruments更容易识别潜在的问题区域。它甚至能够自动检测内存问题的类型并且进行标记，方便我们的分析。使用Instruments来监测和跟踪如下情况：</p>
<p><strong>Overall Memory Use：</strong>监控APP如何使用内存并且与系统中其他活跃进程使用内存进行比较。寻找内存使用大的或者意想不到的内存增长。可以看<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/MonitoringMemoryUsage.html#//apple_ref/doc/uid/TP40004652-CH33-SW1" target="_blank" rel="external">Monitor Memory Usage</a>.</p>
<p><strong>Leaked Memory</strong>：在某个点内存已经被分配，但是一直被释放掉并且不再被APP引用。正是因为并没有对象引用该区域内存，因此无法释放此处内存，该内存也不能够被再一次使用。例如：假定我们编写一个APP，在绘制的时候创建了一个矩形对象，但是当绘制结束却从未释放该对象。在这种情况下：我们的APP可能泄露越来越多的内存。为了解决泄露，我们需要知道哪一个对象并没有被释放掉，这时修改APP在适合的适合释放该对象。 <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingLeakedMemory.html#//apple_ref/doc/uid/TP40004652-CH81-SW1" target="_blank" rel="external">Find Memory Leaks</a></p>
<p><strong>Abandoned Memory</strong>：由于某些原因内存被分配了，但是它并不需要和被引用。例如：假设我们的APP中在图片被缓存之后又添加了图片(images)到缓存，使用了两倍的内存存储相同的images。或者，APP中拥有一个包含对象的数组，为了能够在需要的时候访问，但是事实上你从未使用。不像内存泄露，被遗弃的内存(abandoned memory)好像仍然在APP中的某个地方引用。它仅仅是没有目的性，因为在技术上是合理的，所以对于nstruments来说，Abandoned Memory更难识别，需要更多的检测工作。<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/FindingAbandonedMemory.html#//apple_ref/doc/uid/TP40004652-CH80-SW1" target="_blank" rel="external">Find Abandoned Memory</a>.</p>
<p><strong>Zombies：</strong>这是内存已经被释放并且不再需要了，但是在代码中仍然有某个地方引用了它。例如：假设你的APP中包含了图片缓存，一旦缓存被清理，在APP中不能够尝试着引用不存在的对象。对于这些不存在的对象，我们称之为僵尸对象(zombies) 。<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/EradicatingZombies.html#//apple_ref/doc/uid/TP40004652-CH82-SW1" target="_blank" rel="external">Find Zombies</a>.</p>
<p>由于内存问题能够变得非常困难被发现，为了寻找意想不到或者无限制的内存增长，可以对APP的不同阶段进行周期性快拍(snapshots )。我们能够对比快拍来确定对象是怎样被分配和释放，和内存的超时使用。</p>
<p>通过持续执行一系列重复的用户行为，导致APP进入新的状态和回到最初状态，对于测试APP非常重要。这种类型的搜索称为generational analysis，每次APP进入新的状态，“generation”对象将被创建。在大多数情况下，当APP回到最初状态的时候，你应该期待这些对象被释放掉。例如：如果APP打开了Window，当Window被关闭的时候，任意的Window对象都应该被释放掉。如果这些对象没有被释放掉，这是可能会发生内存问题。当执行generational analysis，初始化generationa可能呈现比我们预期的情况产生更大的内存，由于缓存和初始化过程。因此，需要多次重复用户动作，为了获得真实的APP体验感觉。对于更深层次的内存问题，可以看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="external">Advanced Memory Management Programming Guide</a>.</p>
<h1 id="Monitor-Memory-Usage"><a href="#Monitor-Memory-Usage" class="headerlink" title="Monitor Memory Usage"></a>Monitor Memory Usage</h1><p><strong>使用Activity Monitor性能模板来跟踪APP真实和虚拟内存，并且可以对照运行在系统上的其它的进程的。</strong></p>
<p><strong>创建跟踪文件监控整体内存使用情况</strong></p>
<p>1：Launch Instruments. 启动Instruments</p>
<p>2：In the profiling template selection dialog that appears, click Activity Monitor.  选择Activity Monitor</p>
<p>3：Choose your device and app from the target device and process lists. 选择设备和APP</p>
<p>4：Click Choose to create a trace document. 创建跟踪文件</p>
<p>Activity Monitor 性能分析模板包括Activity Monitor 工具，并且预先被配置显示系统加载和虚拟内存的大小。我们能够使用其他内存相关的统计来并使用监控面板来查看。</p>
<p><strong>显示监控的内存统计</strong></p>
<p>1：Press Command-1 to display the record settings area of the inspector pane (if it’s not already opened). 如果录制设置部分没有打开，可以使用 Command-1 进行打开</p>
<p>2：In the statistics to list area of the inspector, select the memory-related statistics you want to see.The following memory-related statistics are available for display:在监控面板区域的statistics to list 可以选择与内存相关的统计选项，下面是可以获取的显示：</p>
<p><strong>Physical Memory Wired —</strong>The amount of memory being used by the operating system  操作系统所使用的内存情况</p>
<p><strong>Physical Memory Active</strong>  —The amount of memory being used by processes other than the operating system.   对比操作系统其它进程使用的内存数量</p>
<p><strong>Physical Memory Inactive</strong>—The amount of memory that was recently released 最近释放的内存数量</p>
<p><strong>Physical Memory Used</strong>—The total amount of memory that was used while performing the sample 当执行采样时，全部使用的内存数量</p>
<p><strong>Physical Memory Free</strong>—The amount of available memory.  可获得的内存数量</p>
<p><strong>Total VM Size</strong>—The total size of virtual memory.  虚拟内存的全部数量</p>
<p><strong>VM Page In Bytes</strong>—The amount of memory calls sent to RAM. 内存调用发送到RAM的数量</p>
<p><strong>VM Page Out Bytes</strong>—The amount of memory calls sent to disk.  内存调用发送到磁盘的数量</p>
<p><strong>VM Swap Used</strong>—The amount of memory called from disk. 磁盘内存被调用的梳理</p>
<p>3：In the system statistics area, select the memory-related statistics you want to see. If desired, click the shape or color controls to change how the statistics are represented in the timeline.  在系统统计区域，选择我们想统计的与内存相关的选项，点击shape或Color可以改变在timeline的统计显示</p>
<p><strong>为了获取整体内存的使用详情</strong></p>
<p>1：Click the Record button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_record_button_2x.png" alt="image: ../Art/inline_record_button_2x.png">) in the toolbar or press Command-R to begin recording. 点击录制按钮开始记录</p>
<p>2：Use your app normally. 正常使用APP</p>
<p>​      As the Activity Monitor instrument profiles your app, it performs samples at periodic intervals and displays the results in the timeline and detail panes.</p>
<p>3：Click the Stop button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_stop_button_2x.png" alt="image: ../Art/inline_stop_button_2x.png">) in the toolbar or press Command-R again when you’re ready to stop recording. 停止记录</p>
<p>建议：当APP配置后，选择在timeline中插入旗帜(flag)来指示这里有执行具体的任务。例如：在创建新的document之前添加flag，当我们探索分析获取的数据，可以直接到flag去进行分析。</p>
<p>时间面板(timeline pane)提供了图示显示收集的数据。滚动timeline能够理解APP和其他运行系统上进程是如何使用内存的。对于跟多详情，可以进一步理解详情面板。</p>
<p><strong>To view summarized memory usage by sample</strong></p>
<p>1：Click the Activity Monitor track in the timeline.  在timeline点击Activity Monitor进行跟踪</p>
<p>2：Choose Samples from the detail type list in the navigation bar of the detail pane. 选择采样</p>
<p><strong>To view detailed memory usage by a process at a specific point during profiling</strong></p>
<p>1：Click the Activity Monitor track in the timeline  在timeline点击Activity Monitor进行跟踪</p>
<p>2：Press Command-2 to display the display settings area of the inspector pane (if it’s not already opened). 打开详情面板</p>
<p>3：In the process detail tracking area of the inspector, click “Track inspection head” to configure the detail pane to display results based on the currently selected area in the timeline, rather than the latest sample performed. 在监控面板中的过程详情跟踪，点击“Track inspection head”来配置详情面板，基于当前选中的timeline，而不是最新执行的采样</p>
<p>4：Select a point in the timeline to view the statistics that were captured at that time. 选中timeline中的点查看数据</p>
<p>5：View memory usage statistics in the detail pane.  在详情面板看内存使用统计</p>
<p>Use the detail type list to toggle between a summary view of the collected data by process or a parent child view.</p>
<h1 id="Find-Abandoned-Memory"><a href="#Find-Abandoned-Memory" class="headerlink" title="Find Abandoned Memory"></a>Find Abandoned Memory</h1><p>Allocations 性能模板使用Allocation和VM Tracker工具来测量APP整体和虚拟内存的使用。但是，为了查找未使用的内存(abandoned memory)即内存已经被分配但是并没有使用，应该集中于Allocations工具，该工具测量堆内存的使用并且追踪分配，包括由类分配的具体对象。</p>
<p>由于未使用的内存是仍然在APP的某个地方被引用，所以Instrument不能够确定它的重要性。为了找到该部分未使用的内存，使用generational analysis确保在重复执行相同的操作时，内存不会持续增长。例如：结束和开始一个新的游戏，打开和关闭Window，创建和删除联系，所有的操作都未设置优先权，得到稳定的内存状态。大量的循环操作不应该导致未知的内存增加。Instrument能够帮助我们找到相关内存增长对应的具体对象，以至于我们能够释放这些对象减低APP的内存足迹。</p>
<p><strong>To look for abandoned memory in your app</strong></p>
<p>1：Launch Instruments.           启动Launch Instruments.</p>
<p>2：In the profiling template selection dialog that appears, click Allocations.     在出现的性能分析框中选中 Allocations</p>
<p>3：Choose your device and app from the target device and process lists.        选中设备和APP</p>
<p>4：Click Choose to create a trace document.                 点击Choose创建trace document</p>
<p>5：Click the Allocations instrument in the timeline pane.                在时间面板中点击Allocations工具</p>
<p>6：Press Command-2 to show the display settings area of the inspector pane.This gives you quick access to the Mark Generation button, which you use to flag different generations of actions as you profile your app.             点击 Command-2 显示设置区域，或者直接在最右侧面板中点击中间齿轮⚙按钮，这里我们可以访问Mark Generation按钮，可以用来标记不同的 generations</p>
<p>7：Click the Record button  in the toolbar (or press Command-R) to begin recording.               点击录制按钮开始记录</p>
<p>8：Perform a short sequence of repeatable actions in your app.In order to accurately generate trends, this should be a set of actions that starts and finishes with the app in the same state.             在APP中执行一系列重复的行为,来获取准确的数据</p>
<p>9：Click the Mark Generation button in the inspector pane.             点击右侧监督面板中，设置区域下的Mark Generation按钮，实现快照。快照成功显示在详情面板</p>
<p>​     A flag appears in the track pane to identify the generation.            一个红旗标志将显示在轨道上标识generation</p>
<p>​     A list of generations you’ve marked is shown in the detail pane. Each generation includes a list of allocations that has occurred since the previous generation. </p>
<p>​    详情面板会显示一系列的generation，每一个generation都包括从之前generation开始的一系列分配。</p>
<p>​      You can also mark generations after you’re done recording by dragging the inspection head in the track pane’s timeline to the desired location and clicking Mark Generation. 我们也可以在录制结束之后 mark generations，通过拖动检测头到时间轴面板中需要的位置并进行Mark Generation。</p>
<p>10：Perform steps 8 and 9 several times while monitoring the detail pane until you see whether memory is growing without limit. 当监控详情面板执行步骤8和9几次一直到你看到内存是否无限制地增长。</p>
<p>11：Click the Stop button in the toolbar (or press Command-R again) when you’re ready to stop recording. 点击停止按钮停止记录</p>
<p>12：Scan through the generations in the detail pane and find one that seems representative of repeated memory growth. 扫描详情面板的generations 并找到一个反复内存增长的</p>
<p>​      The Growth and # Persistent columns tell you how much additional memory and how many allocations have occurred since the previous generation. If your app returns to its original state after an operation, you shouldn’t expect there to be growth from generation to generation.           Growth 和 # Persistent 专栏将告诉我们对比之前的快照又增加了多少内存，又有多少被分配。如果在执行一次操作之后返回了最初的状态，那么这里将不会有内存的增长。</p>
<p>13：Click the disclosure triangle of a generation to display new objects that have been allocated since the prior generation. 点击三角符号来显示已经被分配的新对象</p>
<p>14：Look for objects that are persisting. If you identify one, click the disclosure triangle to display its instances. 寻找持久化的对象，如果确认了，点击三角显示对应的实例</p>
<p>15：Select an object instance. 选择对象实例</p>
<p>16：Press Command-3 to display a stack trace for the selected instance in the extended detail area of the inspector. 按压Command-3在监督的扩展面板区域中显示选中实例的轨道踪迹</p>
<p>This stack trace provides the complete list of method calls responsible allocating the instance.      该轨道跟踪提供了完整的创建实例的方法列表</p>
<p>17：Click the Collapse button  in the extended detail area to hide system calls in the stack trace. This makes it easier to locate your app’s methods.</p>
<p>Calls made by your app are colored black and preceded by a user code icon  点击按钮隐藏系统在轨道踪迹中的的调用，这样更加容易定位APP的方法</p>
<p>18：Double-click a method in the stack trace to display its code in Instruments.        双击在堆栈轨道中现实的方法</p>
<p>19：Click the Xcode button at the top of the detail pane to open the code in Xcode for editing.         点击顶部的Xcode按钮打开工程进行编辑</p>
<p>20：Determine whether the allocation is useful. If it’s not, it’s abandoned memory that needs to be resolved.        确定分配是否有用，如果没有用，那么背抛弃的内存需要被处理</p>
<h1 id="Find-Memory-Leaks"><a href="#Find-Memory-Leaks" class="headerlink" title="Find Memory Leaks"></a>Find Memory Leaks</h1><p>Leaks分析模板使用了Allocations和Leaks工具来测量APP整体的内存使用并检查泄露，泄漏即内存已分配给对象但是对象不在被引用和获取。</p>
<p>注意：如果Instruments有权利获取APP中的源码信息，那么内存泄露会通过类名报道。否则，内存泄露将使用内存地址显示对应的部分，比如：Malloc-size.为了确保Instruments有权利获取APP代码信息，在Xcode中初始化profiling(see<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Recording,Pausing,andStoppingTraces.html#//apple_ref/doc/uid/TP40004652-CH12-SW10" target="_blank" rel="external">Profile from Xcode</a>) 或者 配置符号映射文件(configure a symbol mappings file see <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/LocatingSymbolsforYourData.html#//apple_ref/doc/uid/TP40004652-CH87-SW1" target="_blank" rel="external">Map Data to Source Code</a>).</p>
<p><strong>To look for memory leaks</strong></p>
<p>1：Launch Instruments.</p>
<p>2：In the profiling template selection dialog that appears, click Leaks.</p>
<p>3：Choose your device and app from the target device and process lists.</p>
<p>4：Click Choose to create a trace document.</p>
<p>5：Click the Record button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_record_button_2x.png" alt="image: ../Art/inline_record_button_2x.png">) in the toolbar (or press Command-R) to begin recording.</p>
<p>6：Use your app normally.</p>
<p>7：Watch the Leaks instrument in the timeline pane for leaks. A leak appears as a red bar.   在时间轴面板观察Leaks工具，如果有内存泄露将会显示红色小状态图形</p>
<p>8：Click the Leaks instrument in the timeline pane to display leak-related information in the detail pane.  点击 Leaks instrument，在详情面板查看相关信息</p>
<p>9：Choose Call Tree from the detail type list in the navigation bar of the detail pane.  在详情面板的高航条中选择 Call Tree</p>
<p>​     A list of method calls related to any detected leaks is displayed.   容易和内存泄露被检测到都会显示在详情面板中</p>
<p>10：Press Command-2 to show the display settings area of the inspector pane.</p>
<p>11：Under the Call Tree display settings, select Invert Call Tree and Hide System Libraries.    在Call Tree显示设置区域，选中 Invert Call Tree 和 Hide System Libraries</p>
<p>The most recent method calls are shown first. It also helps narrow down the list of method calls to ones made by your app. Method calls made by your app are colored black and preceded by a user code icon (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_usercode_icon_2x.png" alt="image: ../Art/inline_usercode_icon_2x.png">).   最近的方法调用将首先显示。它还有助于缩小的列表方法调用的应用程序</p>
<p>12：In the call tree, select a method call you want to investigate.   在 call tree中，选择我们想调查的方法</p>
<p>13：Press Command-3 to display a stack trace for the selected method call in the extended detail area of the inspector.  Command-3在监督区域的扩展面板中查看选中方法的轨道踪迹</p>
<p>14：Double-click the method call in the stack trace to display its code in Instruments. 双击方法定位代码</p>
<p>15：Click the Xcode button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_xcode_2x.png" alt="image: ../Art/inline_xcode_2x.png">) at the top of the detail pane to open the code in Xcode for review and editing.  点击顶部的Xcode按钮调到对应代码部分进行编辑和修改。</p>
<p>在打开Xcode查看代码所创建的内存泄露，内存泄露可能仍然不清楚，即不是那么明显，Leaks instrument允许我们使用详情面板中的 Cycles &amp; Roots查看循环泄露</p>
<p><strong>To investigate a leaked object using cycles and roots 使用cycles and roots 查找泄露对象</strong></p>
<p>1：Click the Leaks instrument in the timeline pane to display leak-related information in the detail pane.    点击Leaks instrument 显示相关的内存泄露信息</p>
<p>2：Choose Cycles &amp; Roots from the detail type list in the navigation bar of the detail pane. 选择详情面板导航条上的Cycles &amp; Roots</p>
<p>A list of leaked objects by cycle is displayed.  可以看到循环引用的对象，下图是两个对象发生循环引用之后显示的图表：</p>
<p>3：Select an object you want to investigate.  选择想要调查的对象</p>
<p>4：If available, view the object graph for the object. 如果可以，查看对象的图表</p>
<p>5：Click the focus arrow (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/icon_detail_pane_gotoarrow_2x.png" alt="image: ../Art/icon_detail_pane_gotoarrow_2x.png">) next to the object to display the memory history of the object in the detail pane, along with corresponding reference counts and method calls.   </p>
<p>6：Press Command-3 to display a stack trace for the selected object in the extended detail area of the inspector.</p>
<p>7：Click the Collapse button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_hidesystemcalls_button_2x.png" alt="image: ../Art/inline_hidesystemcalls_button_2x.png">) in the extended detail area to hide system calls in the stack trace. This makes it easier to locate your app’s methods.</p>
<p>8：Double-click a method in the stack trace to display its code in Instruments.</p>
<p>9：Click the Xcode button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_xcode_2x.png" alt="image: ../Art/inline_xcode_2x.png">) at the top of the detail pane to open the code in Xcode for review and editing.</p>
<hr>
<p><strong>To investigate a leak using the call tree 使用call tree查找泄露</strong></p>
<p>1：Click the Leaks instrument in the timeline pane to display leak-related information in the detail pane.</p>
<p>2：Select Call Tree from the detail type list in the navigation bar of the detail pane.A list of method calls related to any detected leaks is displayed.</p>
<p>3：Press Command-2 to show the display settings area in the inspector pane.</p>
<p>4：Under the Call Tree display settings, select Invert Call Tree and Hide System Libraries.</p>
<p>The most recent method calls are shown first. It also helps narrow down the list of method calls to ones made by your app. Method calls made by your app are colored black and preceded by a user code icon</p>
<p>5：Select a method call you want to investigate.</p>
<p>6：Press Command-3 to display a stack trace for the selected method call in the extended detail area of the inspector.</p>
<p>7：Double-click the method call in the stack trace to display its code in Instruments.</p>
<p>8：Click the Xcode button at the top of the detail pane to open the code in Xcode for review and editing.</p>
<p>虽然Instruments能够帮助我们检测内存泄露，但是我们仍然需要仔细查看相关的内存历史和代码来确定并解决问题，下面是一些常常导致泄露的情形：</p>
<p>1：Retain has been called on an object without a corresponding release call when the object is no longer referenced. 循环是当一个对象不再被引用的时候，被没有进行对应的释放</p>
<p>2：An object has been allocated and initialized with APIs that don’t cause the object to autorelease.  对象有被创建和初始化但是并没有被释放</p>
<p>3：If a leak isn’t an object, you may be calling an API that assumes ownership of a <code>malloc</code>-created memory block, and you are missing a corresponding call to <code>free()</code>. </p>
<h1 id="Find-Zombies"><a href="#Find-Zombies" class="headerlink" title="Find Zombies"></a>Find Zombies</h1><p>Zombies性能分析模板使用Allocations工具测量APP的内存使用，集中监测“zombie”对象，该对象是对象被调用，但是该对象已经被释放之后并不存在。</p>
<p>在这个模板中，Allocations工具已经配置了能够检测 NSZombie检测。这是调试模型(debug mode)，需要设置环境变量 <code>NSZombieEnabled</code> 为true，指引编译器使用任意对象替代NSZombie类型的对象，该NSZombie类型的对象已经被释放并且引用计数为0(即对象不存在)。如果向这些已经被释放的对象发送信息，这些对象将被标记，当APP崩溃，记录停止，Zombie信息对话显示。我们能够检测Zombie对象的历史retain和release，确定问题发生的准确位置。</p>
<p><strong>注意：</strong>Zombies模板由于改变了环境，以至于应该被释放的对象并没有真正的被释放，所以导致内存持续增长。这是预期的行为，这也意味除了标志zombie和内存地址，其它由Allocation工具提供的数据应该被忽略，我们不应该添加Leaks工具到Zombies模板，这将导致不准确的结果，对于iOS APP，使用Zombies模板需要使用iOS模拟器而不是真机。</p>
<p><strong>To look for zombies in your app</strong></p>
<p>1：Launch Instruments.</p>
<p>2：In the profiling template selection dialog that appears, click Zombies.</p>
<p>3：Choose your device and app from the target device and process lists.</p>
<p>4：Click Choose to create a trace document.</p>
<p>5：Click the Record button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_record_button_2x.png" alt="image: ../Art/inline_record_button_2x.png">) in the toolbar (or press Command-R) to begin recording.</p>
<p>6：Use your app normally. </p>
<p>如果调用了已经被释放的对象，那么将会在时间轴面板中插入标记，并且显示 Zombie 信息对话框，在具体内存地址显示信息被发送给了已经释放的对象。</p>
<p>如果关闭Zombie 信息对话框，可以点击标识能够重新打开。</p>
<p>7：Click the focus arrow (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/icon_detail_pane_gotoarrow_2x.png" alt="image: ../Art/icon_detail_pane_gotoarrow_2x.png">) next to the zombie’s memory address to display the memory history of the zombie object in the detail pane, along with corresponding reference counts and method calls. </p>
<p>8：Select the Zombie event (or any other event you want to investigate) in the detail pane.</p>
<p>9：Press Command-3 to display a stack trace for the selected event in the extended detail area of the inspector.</p>
<p>10：Click the Collapse button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_hidesystemcalls_button_2x.png" alt="image: ../Art/inline_hidesystemcalls_button_2x.png">) in the extended detail area to hide system calls in the stack trace. This makes it easier to locate your app’s methods.Calls made by your app are colored black and preceded by a user code icon (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_usercode_icon_2x.png" alt="image: ../Art/inline_usercode_icon_2x.png">).</p>
<p>11：Double-click a method in the stack trace to display its code in Instruments.</p>
<p>12：Click the Xcode button (<img src="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Art/inline_xcode_2x.png" alt="image: ../Art/inline_xcode_2x.png">) at the top of the detail pane to open the code in Xcode for editing.</p>
<p>虽然Instruments能够帮助我们检测zombies,，但是我们仍然需要仔细查看相关的内存历史和代码来确定并解决问题，下面是一些常常导致泄露的情形：</p>
<p>1：An object has already been released (or autoreleased), and your app tries to release it again. 对象已经被释放掉，APP尝试再release</p>
<p>2：An object hasn’t been retained when it should have been. 当对象需要被retained的时候并没有被retained</p>
<p>3：Some other call is made to an object after it has been released. 在对象释放之后，被再次使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/内存管理之-引用计数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/内存管理之-引用计数/" itemprop="url">内存管理之 引用计数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T16:08:28+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存管理-引用计数"><a href="#内存管理-引用计数" class="headerlink" title="内存管理 - 引用计数"></a>内存管理 - 引用计数</h3><h5 id="1-内存管理原理：引用计数"><a href="#1-内存管理原理：引用计数" class="headerlink" title="1.内存管理原理：引用计数"></a>1.内存管理原理：引用计数</h5><p><strong>引用计数发展时间轴：</strong></p>
<p>苹果在 2011 年的时候，在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员。</p>
<p>直到 2013 年左右，苹果认为 ARC 技术足够成熟，直接将 macOS（当时叫 OS X）上的垃圾回收机制废弃，从而使得 ARC 迅速被接受。</p>
<p>2014 年的 WWDC 大会上，苹果推出了 Swift 语言，而该语言仍然使用 ARC 技术，作为其<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" target="_blank" rel="external">内存管理方式</a>。</p>
<p><strong>虽然 ARC 帮我们解决了引用计数的大部分问题，但是还有一部分工作需要我们自己来处理</strong>。内存问题可能会导致内存泄漏，使得应用运行缓慢或者被系统终止进程。</p>
<p>所以要想处理好内存问题，我们首先需要理解引用计数这种内存管理方式。</p>
<p><strong>什么是引用计数</strong>？</p>
<p>引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效</p>
<p>为了更形象一些，我们再来看一段 Objective-C 的代码。新建一个工程，因为现在默认的工程都开启了自动的引用计数 ARC（Automatic Reference Count)，我们先修改工程设置，给 AppDelegate.m 加上 <code>-fno-objc-arc</code> 的编译参数（如下图所示），这个参数可以启用手工管理引用计数的模式。</p>
<p><img src="/Users/sunmingyue/Desktop/WechatIMG163.jpeg" alt="WechatIMG163"></p>
<p><strong>为什么采用了引用计数的方式来管理内存呢？</strong></p>
<p>上述例子比较简单，可能看不出引用计数的真正的用处，因为该对象的生命周期在一个函数内，即时不修改它的引用计数的也是可以的，只需要在函数返回前将该对象销毁即可。</p>
<p>引用计数真正派上用场的场景是用于对象之间传递和共享数据。我们举一个具体的例子：</p>
<p>场景1：</p>
<p>按照假设有两个Cotnroller，分别为ControllerA、ControllerB，ControllerA中将对象M传递给ControllerB，在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，那么ControllerA 就需要在ControllerB 不再需要对象M的时候，将 M 销毁。但ControllerB可能只是临时用一下对象 M，也可能觉得对象 M 很重要，将它设置成自己的一个成员变量，那这种情况下，什么时候销毁对象 M 就成了一个难题。</p>
<p>场景2：</p>
<p>对于这种情况，有一个暴力的做法，就是ControllerA 在调用完ControllerB之后，马上就销毁参数对象 M，然后ControllerB 需要将参数另外复制一份，生成另一个对象 M2，然后自己管理对象 M2 的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。</p>
<p>场景3：</p>
<p>我们另外还有一种办法，就是ControllerA 在构造完对象 M 之后，始终不销毁对象 M，由ControllerB 来完成对象 M 的销毁工作。如果ControllerB 需要长时间使用对象 M，它就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好地解决了对象复制的问题，但是它强烈依赖于 ControllerA、ControllerB 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象 M 的申请是在ControllerA中，释放在ControllerB 中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如ControllerB 需要再向ControllerC传递对象 M，那么这个对象在ControllerC 中又不能让对象 C 管理。所以这种方式带来的复杂性更大，更不可取。</p>
<p>所以引用计数很好的解决了这个问题，在参数 M 的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加 1，使用完了之后再把引用计数减 1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/浅析栈区和堆区内存分配的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/浅析栈区和堆区内存分配的区别/" itemprop="url">浅析栈区和堆区内存分配的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T16:07:25+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浅析栈区和堆区内存分配的区别"><a href="#浅析栈区和堆区内存分配的区别" class="headerlink" title="浅析栈区和堆区内存分配的区别"></a>浅析栈区和堆区内存分配的区别</h1><p>一直以来总是对这个问题的认识比较朦胧，我相信很多朋友也是这样的，总是听到内存一会在栈上分配，一会又在堆上分配，那么它们之间到底是怎么的区别呢？为了说明这个问题，我们先来看一下内存内部的组织情况．</p>
<p><img src="/Users/sunmingyue/Desktop/2.jpeg" alt="1"></p>
<p>从上图可知，程序占用的内存被分了以下几部分．</p>
<p><strong>1、栈区（stack）</strong>由编译器自动分配释放 ，存放函数的参数值，局部变量的值等，内存的分配是连续的，类似于平时我们所说的栈，如果还不清楚，那么就把它想成数组，它的内存分配是连续分配的，即，所分配的内存是在一块连续的内存区域内．当我们声明变量时，那么编译器会自动接着当前栈区的结尾来分配内存．</p>
<p><strong>2、堆区（heap）</strong>一般由程序员分配释放， 若程序员不释放，程序结束时可能由操作系统回收．类似于链表，在内存中的分布不是连续的，它们是不同区域的内存块通过指针链接起来的．一旦某一节点从链中断开，我们要人为的把所断开的节点从内存中释放．</p>
<p><strong>3、全局区（静态区）（static）</strong>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放</p>
<p><strong>4、文字常量区</strong>常量字符串就是放在这里的。 程序结束后由系统释放</p>
<p><strong>5、程序代码区</strong>存放函数体的二进制代码。</p>
<p>char c; //栈上分配<br>char *p = new char[3]; //堆上分配，将地址赋给了p;</p>
<p>在 编译器遇到第一条指令时，计算其大小，然后去查找当前栈的空间是大于所需分配的空间大小，如果这时栈内空间大于所申请的空间，那么就为其分配内存空间，注 意：在这里，内在空间的分配是连续的，是接着上次分配结束后进行分配的．如果栈内空间小于所申请的空间大小，那么这时系统将揭示栈溢出，并给出相应的异常 信息．</p>
<p>编译器遇到第二条指令时，由于p是在栈上分配的，所以在为p分配内在空间时和上面的方法一样，但当遇到new关键字，那么编译器都知道，这是用户申请的动态内存空间，所以就会转到堆上去为其寻找空间分配．大家注意：堆上的内存空间不是连续的，它是由相应的链表将其 空间区时的内在区块连接的，所以在接到分配内存空间的指定后，它不会马上为其分配相应的空间，而是先要计算所需空间，然后再到遍列整个堆（即遍列整个链的 节点），将第一次遇到的内存块分配给它．最后再把在堆上分配的字符数组的首地址赋给p.，这个时候，大家已经清楚了，p中现在存放的是在堆中申请的字符数组的首地址，也就是在堆中申请的数组的地址现在被赋给了在栈上申请的指针变量p．为了更加形象的说明问题，请看下图：<br><img src="http://files.jb51.net/file_images/article/201308/201308130909595.jpg" alt="img"></p>
<p>从上图可以看出，我们在堆上动态分配的数组的首地址存入了指针p所指向的内容．</p>
<p><strong>请注意：</strong>在栈上所申请的内存空间，当我们出了变量所在的作用域后，系统会自动我们回收这些空间，而在堆上申请的空间，当出了相应的作用域以后，我们需要显式来释放所申请的内存空间，如果我们不及时得对这些空间进行释放，那么内存中的内存碎片就越来越多，从而我们的实际内存空间也就会变的越来越少，孤立的内存块越来越多。在这里，我们知道，堆中的内存区域不是连续的，还是将有效的内存区域经过链表指针连接起来的，如果我们申请到了某一块内存，那么这一块内存区将会从连续的（通过链表连接起来的）内存块上断开，如果我们在使用完后，不及时的对它进行释放，那么它就会孤立的开来，由于没有任何指针指向它，所以这个区域将成为内存碎片，所以在使用完动态分配的内存后，一定要显式的对它进行释放.</p>
<p>小结： </p>
<p>1 、内存分配方面：</p>
<p>​    堆：堆是向高地址扩展的数据结构，一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下： new 、 malloc 、 delete 、 free 等等。</p>
<p>​    栈：栈是向低地址扩展的数据结构，由编译器 (Compiler) 自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>2 、申请方式方面：</p>
<p>​    堆：需要程序员自己申请，并指明大小。在 c 中 malloc 函数如 p1 = (char *)malloc(10) ；在 C++ 中用 new 运算符，但是注意 p1 、 p2 本身是在栈中的。因为他们还是可以认为是局部变量。</p>
<p>​    栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b ；系统自动在栈中为 b 开辟空间。</p>
<p>3 、系统响应方面：</p>
<p>​    堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p>​    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>4 、大小限制方面：</p>
<p>​    堆：是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的 ，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>​    栈： 是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow 。因此，能从栈获得的空间较小。</p>
<p>5 、效率方面：</p>
<p>​    堆：是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<p>​    栈：由系统自动分配，速度较快。但程序员是无法控制的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/浅谈block的应用与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/浅谈block的应用与实现/" itemprop="url">浅谈block的应用与实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T16:06:55+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>浅谈Block的应用及原理</strong></p>
<hr>
<p><strong>1.使用：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSInteger (^mySum)(NSInteger,NSInteger) = ^(NSInteger paramA, NSInteger paramB)&#123;</div><div class="line">return paramA + paramB;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上定义了一个Block变量，block本来就是一个程序段，因此有返回值有输入的参数，这里这个block返回的类型是BOOL ，“^”表示block定义开始，block名称mySum紧跟在^符号之后，这里这个block接受一个NSInteger类型的参数。</p>
<p><strong>调用这个block的方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mySum(1,3);</div><div class="line">NSLog(@&quot;sum is %ld&quot;,mySum(1,3)); // sum is 4</div></pre></td></tr></table></figure>
<p>上述block内部使用了接受的两个NSInteger类型参数，除此之外，<strong>block外的变量也可以在block内部使用</strong>，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSInteger paramC = 5;</div><div class="line">// Block变量定义</div><div class="line">NSInteger (^sum)(NSInteger,NSInteger) = ^(NSInteger paramA, NSInteger paramB)&#123;</div><div class="line">return paramA + paramB + paramC;</div><div class="line">&#125;;</div><div class="line">NSLog(@&quot;sum is %ld&quot;,sum(1,3)); // 输出：sum is 9</div></pre></td></tr></table></figure>
<p>需要注意的一点是，不能在block内部改变本地变量，编译器会直接报错。而更需要注意的是paramC这样的局部变量的变化是不会体现在block里的，比如接着上面的代码，继续写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Block变量定义</div><div class="line">NSInteger (^sum)(NSInteger,NSInteger) = ^(NSInteger paramA, NSInteger paramB)&#123;</div><div class="line">return paramA + paramB + paramC;</div><div class="line">&#125;;</div><div class="line">paramC = 10;</div><div class="line">NSLog(@&quot;sum is %ld&quot;,sum(1,3));// 输出：sum is 9</div></pre></td></tr></table></figure>
<p>输出依旧是：“sum is 9”，paramC赋值为10，但是在block内部的paramC的值依旧是5，这是因为block内部的paramC在block声明是copy了一份到block内，block外部的paramC的变化与block无关，可以理解为paramC为值类型（值类型，只引用了数据，没有对变量进行地址引用）。如果paramC为引用类型的话，外部的变化会影响block内部（引用类型，直接对地址进行引用）。</p>
<p>如果需要传递个block变量值，可以将变量声明为___block，可以使用实例变量。</p>
<p>例：将变量声明为___block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Block变量定义</div><div class="line">__block NSInteger paramC = 5;</div><div class="line">NSInteger (^sum)(NSInteger,NSInteger) = ^(NSInteger paramA, NSInteger paramB)&#123;</div><div class="line">return paramA + paramB + paramC;</div><div class="line">&#125;;</div><div class="line">paramC = 10;</div><div class="line">NSLog(@&quot;sum is %ld&quot;,sum(1,3));// 输出：sum is 14</div></pre></td></tr></table></figure>
<p>例：使用实例变量，使用weakSelf避免循环引用问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.paramD = 10;</div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line"></div><div class="line">// Block变量定义</div><div class="line">NSInteger (^sum)(NSInteger,NSInteger) = ^(NSInteger paramA, NSInteger paramB)&#123;</div><div class="line">return paramA + paramB + weakSelf.paramD;</div><div class="line">&#125;; </div><div class="line">self.paramD = 20;</div><div class="line">NSLog(@&quot;sum is %ld&quot;,sum(1,3));// 输出：sum is 24</div></pre></td></tr></table></figure>
<p>刚开始使用block感觉语法奇怪，而且书写起来麻烦，我们还可以通过typedef将block进行简单的封装。将上述block进行封装如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef NSInteger (^MySum)(NSInteger, NSInteger);</div></pre></td></tr></table></figure>
<p>使用：声明一个类型MySum类型的block实例，定义内容后直接使用block。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MySum mySum;</div><div class="line">mySum = ^(NSInteger paramA, NSInteger paramB)&#123;</div><div class="line">return paramA + paramB + weakSelf.paramD;</div><div class="line">&#125;; </div><div class="line">self.paramD = 20;</div></pre></td></tr></table></figure>
<p><strong>二、应用</strong></p>
<p>Apple所推荐的block使用范围包括以下几个方面：</p>
<ul>
<li>枚举——通过block获取枚举对象或控制枚举进程</li>
<li>View动画——简单明了的方式规定动画</li>
<li>排序——在block内写排序算法</li>
<li>通知——当某事件发生后执行block内的代码</li>
<li>错误处理——当错误发生时执行block代码</li>
<li>完成处理——当方法执行完毕后执行block代码</li>
<li>GCD多线程——多线程控制</li>
</ul>
<p><strong>三、实现</strong></p>
<p>上文中提到了不能修改局部变量，但使用_block修饰可以修改局部变量，之前很疑惑这是为什么？接下来我们便研究一下block的实现。</p>
<p><strong>研究工具:clang</strong></p>
<p>为了研究编译器是如何实现 block 的，我们需要使用 clang。clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 block 具体的源码实现方式。该命令是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc block1.c</div></pre></td></tr></table></figure>
<p>使用上述命令编译后，我们得到一份block1.cpp文件，在这份文件中我们可以看到以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">void *isa;</div><div class="line">int Flags;</div><div class="line">int Reserved;</div><div class="line">void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>block 的数据结构定义如下，通过该图，我们可以知道，一个 block 实例实际上由 4 部分构成：</p>
<ol>
<li>isa 指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li>flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</li>
<li>reserved，保留变量。</li>
<li>FuncPtr，block对应的函数指针。</li>
</ol>
<p>接下来，我们看一下，只输出以一句话的block的什么样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">void (^myBlock)(void) = ^&#123;</div><div class="line">printf(&quot;hello, block&quot;);</div><div class="line">&#125;;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的中间代码有500多行，我们抽出主要的代码如下图：</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/WechatIMG65.jpeg" alt="WechatIMG65"></p>
<p>首先出现的结构体就是<strong>_main_block_impl0</strong>，可以看出是根据所在函数（main函数）以及出现序列（第0个）进行命名的。如果是全局block，就根据变量名和出现序列进行命名。</p>
<p><strong>main_block_impl_0中包含了两个成员变量和一个构造函数，成员变量分别是</strong>block_impl结构体和描述信息Desc。</p>
<p>接着出现的是<strong>_main_block_func0</strong>函数，即block对应的函数体。该函数接受一个<strong>__cself</strong>参数，即对应的block自身。</p>
<p>接这出现的是<strong>_main_block_desc0</strong>结构体，其中比较有价值的信息是block大小。</p>
<p>最后就是main函数中对block的创建和调用，可以看出<strong>执行block</strong>就是调用一个以block自身作为参数的函数，这个函数对应着block的执行体。</p>
<p>赋值代码中，类型转换太多了，我们去掉类型转换后如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//去掉类型转换后的代码</div><div class="line">void (*myBlock)(void) = &amp;__main_block_impl_0(参数1, 参数2);</div></pre></td></tr></table></figure>
<p>Block语法赋值给myBlock，相当于把<em>_main_block_impl</em>0的函数地址指针赋值给myBlock。</p>
<p>参数一 为 main_block_func<em>0，也就是匿名函数的函数名称，通过main_block_impl</em>0的定义可以知道main_block_func_0赋值给了FuncPtr。</p>
<p>参数二 为 main_block_desc<em>0</em>DATA，是 main_block_impl_0 的结构体的大小。</p>
<p><em>_main_block_impl</em>0这里可以看到，block的类型用<strong>_NSConcreteStackBlock</strong>来表示，表明这个block位于栈中。同样地，block类型还有<strong>_NSConcreteMallocBlock</strong>和<strong>_NSConcreteGlobalBlock</strong>。</p>
<p>由block_impl中isa，得知block也是NSObject，我们可以对其进行retain操作。不过在将block作为回调函数传递给底层框架时，底层框架对其<strong>copy</strong>了一份。如果将回调block作为属性，不能用retain，而要用copy。我们通常会将block写在栈中，而需要回调时，往往回调block栈已经不存在了，使用copy属性可以将block放到堆中。</p>
<p><strong>修改局部变量</strong></p>
<p>再看一个访问局部变量的block是怎样的。</p>
<p>在main函数中添加局部变量，并且打印这个局部变量</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/Pasted Graphic.tiff" alt="Pasted Graphic"></p>
<p>重新编译得到的中间文件源码如下：</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/WechatIMG90.jpeg" alt="WechatIMG90"></p>
<p>可以看出block结构体<em>_main_block_impl</em>0多了个成员变量i，用来存储使用到的局部变量i,</p>
<p>如果我们尝试修改局部变量i，则会得到如下错误：</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/WechatIMG91.jpeg" alt="WechatIMG91"></p>
<p>错误信息很详细，既告诉我们变量不可赋值，也提醒我们要使用<strong>__block</strong>类型标识符。</p>
<p><strong>为什么不能给变量i赋值呢？</strong></p>
<p>因为main函数中的局部变量i和函数main_block_func<em>0不在同一个作用域中，调用过程中只是进行了值传递。当然，在上面代码中，我们可以通过指针来实现局部变量的修改。不过这是由于在调用main_block_func</em>0时，block所在的栈还没有销毁，变量i还在栈中。但是在很多情况下，block被执行时，定义时所在的函数栈已经被销毁，局部变量已经不在栈中了（block此时在哪里？），再用指针访问就奔溃了。</p>
<p>所以对于局部变量，不允许block进行修改是合理的。</p>
<h3 id="block的实现"><a href="#block的实现" class="headerlink" title="__block的实现"></a>__block的实现</h3><p>__block类型变量是如何支持修改的呢？</p>
<p>在main函数中添加局部变量，修改局部变量的值，并且打印这个局部变量：</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/Pasted Graphic 1.tiff" alt="Pasted Graphic 1"></p>
<p>我们通过__block修改局部变量，此时再看中间代码：</p>
<p>此时再看中间代码，会多出很多信息。首先是__block变量对应的结构体：</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/Pasted Graphic 3.tiff" alt="Pasted Graphic 3"></p>
<p>由第一个成员<strong>__isa</strong>指针也可以知道<strong>_Block_byref_i0</strong>也可以是NSObject。</p>
<p>第二个成员<strong>__forwarding</strong>指向自己，为什么要指向自己？指向自己是没有意义的，只能说有时候需要指向另一个<em>_Block_byref_i</em>0结构。</p>
<p>最后一个成员是目标存储变量i。</p>
<p>在下图中可以看到，main_block_impl<em>0的成员变量i变成了Block_byref_i</em>0 类型。</p>
<p><img src="/Users/sunmingyue/Desktop/周总结/浅谈block的应用与实现/Pasted Graphic 2.tiff" alt="Pasted Graphic 2"></p>
<p>对应的函数main_block_func<em>0中，亮点是Block_byref_i</em>0指针类型变量i，通过其成员变量__forwarding指针来操作另一个成员变量。 :-)</p>
<p>接下来再看main函数</p>
<p>通过这样看起来有点复杂的改变，我们可以修改变量i的值。但是问题同样存在：<em>_Block_byref_i</em>0类型变量<strong>i</strong>仍然处于栈上，当block被回调执行时，变量i所在的栈已经被销毁怎么办？</p>
<p>在这种关键时刻，<em>_main_block_desc</em>0站出来了：</p>
<p>此时，main_block_desc<em>0多了两个成员函数：copy和dispose，分别指向main_block_copy</em>0和<em>_main_block_dispose</em>0。</p>
<p>当block从栈上被copy到堆上时，会调用<strong>main_block_copy_0将</strong>block类型的成员变量i从栈上复制到堆上；而当block被释放时，相应地会调用<strong>main_block_dispose_0来释放</strong>block类型的成员变量i。</p>
<p>一会在栈上，一会在堆上，那如果栈上和堆上同时对该变量进行操作，怎么办？</p>
<p>这时候，<strong>forwarding的作用就体现出来了：当一个</strong>block变量从栈上被复制到堆上时，栈上的那个<strong>Block_byref_i_0结构体中的</strong>forwarding指针也会指向堆上的结构。</p>
<p>到此，我们大概了解了block实现，学习过程中参考了很多大神的博客，很感谢大神们的分享。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/gitignore文件的添加/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="爱生活的小悦悦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学然后知不足">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/gitignore文件的添加/" itemprop="url">gitignore文件的添加</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T16:03:14+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>以一个 iOS 项目作为演示，步骤如下：</strong></p>
<ol>
<li>创建一个 iOS 项目。</li>
<li>然后去下载 iOS 工程对应的 .gitignore 文件：<a href="https://github.com/github/gitignore&gt;。" target="_blank" rel="external">https://github.com/github/gitignore&gt;。</a></li>
<li>在下载的文件中找到Objective-C.gitignore。</li>
<li><p>在终端修改Objective-C.gitignore名称为.gitignore。</p>
<p>命令：mv Objective-C.gitignore .gitignore (cd 到Objective-C.gitignore所在的文件夹进行此操作命令)</p>
</li>
<li><p>找到.gitignore文件。</p>
<p>.gitignore在mac系统默认设置中被隐藏了，通过以下命令显示设置显示隐藏文件，重启finder之后，我们会看到.gitignore文件。</p>
<p>显示隐藏文件：defaults write com.apple.finder AppleShowAllFiles -bool true;</p>
<p>不显示隐藏文件：defaults write com.apple.finder AppleShowAllFiles -bool false；</p>
</li>
<li><p>将.gitignore文件放到项目根目录下。</p>
</li>
<li>清除缓存，在终端cd到项目根目录下，执行命令：“ git rm -r –cached .”</li>
<li>再次提交项目是删除了很多文件，而这些类型的文件正是 .gitignore 文件中声明的不需要被 track 的文件。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="爱生活的小悦悦" />
          <p class="site-author-name" itemprop="name">爱生活的小悦悦</p>
           
              <p class="site-description motion-element" itemprop="description">Do one thing at a time and do well</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sunxyy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3778165280" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">爱生活的小悦悦</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"> 访问人数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"> 访问总量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
